<!DOCTYPE html>
<html>

<head>
  <title>Modern Learning Portfolio</title>
  <style>
    /* General Styles */
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1e293b, #0f172a);
      color: #ffffff;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .container {
      width: 90%;
      max-width: 1200px;
      margin: 20px auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Header Styles */
    header {
      text-align: center;
      background: linear-gradient(135deg, #4f46e5, #9333ea);
      color: white;
      padding: 20px 10px;
      border-radius: 15px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      animation: fadeIn 1.5s ease-out;
    }

    header h1 {
      margin: 0;
      font-size: 2.5rem;
    }

    /* Navigation Menu */
    nav {
      margin: 20px 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 25px;
    }

    nav a {
      text-decoration: none;
      background: linear-gradient(135deg, #2563eb, #7c3aed);
      color: white;
      padding: 15px 30px;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease-in-out;
      position: relative;
    }

    nav a:hover {
      background: linear-gradient(135deg, #9333ea, #4f46e5);
      transform: scale(1.1) rotate(3deg);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    /* Page Sections */
    .page {
      display: none;
      width: 100%;
      background: linear-gradient(135deg, #1e293b, #334155);
      padding: 25px;
      border-radius: 15px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      margin-bottom: 20px;
      color: #f3f4f6;
      animation: slideIn 0.5s ease-out;
    }

    .show-page {
      display: block;
    }

    .page h2 {
      margin-top: 0;
      text-align: center;
      color: #60a5fa;
      border-bottom: 2px solid #7c3aed;
      padding-bottom: 10px;
    }

    .page p {
      line-height: 1.8;
      margin: 10px 0;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-left: 4px solid #2563eb;
    }

    /* Footer */
    footer {
      text-align: center;
      background: linear-gradient(135deg, #9333ea, #4f46e5);
      color: white;
      padding: 15px;
      width: 100%;
      margin-top: auto;
      border-radius: 0 0 15px 15px;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-50px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Button Wiggle Animation */
    @keyframes wiggle {

      0%,
      100% {
        transform: rotate(0deg);
      }

      25% {
        transform: rotate(-3deg);
      }

      50% {
        transform: rotate(3deg);
      }

      75% {
        transform: rotate(-3deg);
      }
    }

    nav a:active {
      animation: wiggle 0.3s ease-in-out;
    }
  </style>
</head>

<body>

  <div class="container">
    <!-- Header -->
    <header>
      <h1>Learning Portfolio</h1>
    </header>

    <!-- Navigation -->
    <nav>
      <a href="#home">Home</a>
      <a href="#project">Project Intro</a>
      <a href="#learning">Reflections</a>
    </nav>

    <!-- Sections -->
    <section id="home" class="page show-page">
      <h2>Home Page</h2>
      <p>Welcome to the Course!</p>
      <p>Course Info<br>This course explores the design and analysis of algorithms, covering fundamental data structures, algorithm efficiency, and real-world applications.</p>
      <p>Data Structures and Algorithms We Studied<br>Arrays, Linked Lists, Stacks, Queues<br>Trees (Binary Search Trees, AVL Trees)<br>Graphs (Representations, Traversals)<br>Sorting Algorithms (Merge Sort, Quick Sort)<br>Searching Algorithms (Binary Search)</p>
      <p>Real-Time Applications<br>These concepts are applied to real-world problems like optimizing warehouse management, network routing, and search engine indexing.</p>
      <p>References<br>Introduction to Algorithms (CLRS)<br>Algorithms (Sedgewick & Wayne)</p>
    </section>

    <section id="project" class="page">
      <h2>Project Introduction</h2>
      <p>Project Overview<br>This project focuses on designing and implementing a Warehouse Management System (WMS). It involves analyzing warehouse operations, identifying key challenges, and developing algorithmic solutions to optimize various processes.</p>
      <p>Business Case Study Identified<br>Optimizing warehouse operations for increased efficiency and reduced costs.</p>
      <p>Problem Definition<br>Design and implement algorithms for inventory management, order fulfillment, and route optimization within a warehouse environment.</p>
      <p>Team Member Details<br>Member 1: [Vikas]<br>Member 2: [Karthik]<br>Member 3: [Abhishek]<br>Member 4: [Goutam]</p>
      <p>Assigned Business Cases (Members Working On)<br>Member 1: Inventory Tracking<br>Member 2: Order Picking Optimization</p>
    </section>

    <section id="learning" class="page">
      <h2>Learning Reflections</h2>
      <p>Gain insights from the learning journey, including challenges and key takeaways.</p>
      <p>In computational problem solving, we encounter different types of problems that mimic the patterns we observe in nature. At a broad level, these can be categorized as iterative, recursive, and backtracking problems. Iterative problems involve repeating a set of operations until a certain condition is met. For example, calculating factorial iteratively is a very direct application. The second meaningful method is recursion, in which a function resolves a problem by calling itself in smaller steps, the Tower of Hanoi or the Fibonacci sequence. Other methods include backtracking, which proves useful for constraint-based problems, such as the N-Queens Problem, in which solutions are constructed incrementally but abandoned when such paths fail to meet given constraints. In particular, algorithms reflect the natural pattern of solving a problem when it involves conditions of complexity and also constraints. Space and time efficiency measure how well an algorithm uses computational resources. Time complexity measures the number of operations required as the input size grows, while space complexity measures memory usage. The importance of these efficiencies is that they directly impact the performance of algorithms in real-world applications. Orders of growth explain the relationship between input size and resource requirements: constant (O(1)), logarithmic (O(log n)), linear (O(n)), quadratic (O(nÂ²)), and exponential (O(2^n)). Some sorting algorithms, for example Quick Sort, are O(n log n), an efficient balance between using resources and producing performance. Understanding these concepts allows one to choose the best algorithms for different problems.</p>
      <p>Important takeaways from Chapter 2's Design Principles<br>Chapter 2 Hashing and Hash Tables: A number of design principles are mentioned here:<br>- Hash Functions: Good hash functions avoid collisions and distribute data evenly so that operations like insertion and search take constant time, O(1).<br>- Collision Avoidance Techniques: Chaining and open addressing are techniques used to handle collisions. Chaining stores collided elements in linked lists, while open addressing searches for an alternative slot.<br>- Practical Applications: Hash tables show that good theoretical work actually translates to very real-world efficiency. They underlie data retrieval systems such as dictionaries and caches. These illustrate why good design should balance efficiency and flexibility.</p>
      <p>The Hierarchical Data and Tree Structures<br>Trees represent hierarchical data and solve numerous problems in computer science. In BST, all three operations searching, insertion and deletion can be done efficiently - that is, O(log n) - if they remain balanced. AVL Trees enhance BSTs by maintaining balance through rotations, ensuring logarithmic performance. Red-Black Trees extend balancing with color-based rules, widely used in databases and file systems. Heaps prioritize quick access to the largest or smallest elements, as seen in priority queues. Tries excel in prefix-based searches, crucial in autocomplete and spellcheck features. Each tree structure optimizes specific problem scenarios, demonstrating the adaptability of hierarchical data representations.</p>
      <p>Need for Algorithm for Array Querying<br>Array query algorithms address issues like accessing, modification, and data analysis. For example, with prefix sums or segment trees, range queries are computed in very little time. In searching operations, arrays make use of the binary search optimization, where their complexity is of logarithmic time, O(log n), hence making arrays core in handling structured data. The applications include such diverse fields as database indexing, computational biology, thus underlining versatility and necessity in robust query mechanisms.</p>
      <p>Trees vs. Graphs<br>Trees and graphs are both relation representations but fundamentally different. Trees are hierarchical structures with a single root and acyclic connections. Graphs generalize this concept, allowing cycles and multiple root-like nodes. Tree traversal methods, such as Inorder, Preorder, and Postorder, are linear and well-defined. Graph traversal, encompassing Depth-First Search (DFS) and Breadth-First Search (BFS), adapts to cyclic and acyclic scenarios. Trees are great for hierarchical representations like file systems, and graphs solve complex network problems like social connections or transportation systems. The diversity of their application underlines the adaptability of data structures to various applications.</p>
      <p>Sorting and Searching Algorithms and Real-World Connections<br>Sorting and searching are foundational algorithmic techniques. Sorting methods, such as Quick Sort (divide and conquer) and Merge Sort (stable and efficient), order data efficiently for further processing. Searching algorithms, including binary search, find elements in sorted datasets with logarithmic complexity. Real-world applications abound: search engines rely on efficient algorithms to retrieve information, while sorting underpins database query optimizations. These techniques bridge theoretical design with practical utility.</p>
      <p>Graph Algorithms: Spanning Trees and Shortest Paths<br>Graph algorithms solve key problems such as finding spanning trees and shortest paths. Minimum Spanning Tree algorithms, like Kruskal's and Prim's, optimize network connections such as power grids or communication networks. Shortest path algorithms, like Dijkstra's or A*, give the best route in navigation systems. These applications show how graph algorithms can translate hard problems into implementable solutions and how important it is in today's computation.</p>
      <p>Explored Algorithm Design Techniques<br>The course discusses the following methodologies for algorithm design:<br>- Divide and Conquer: Breaking down problems into smaller subproblems, as seen in Merge Sort.<br>- Dynamic Programming: Solving overlapping subproblems, as illustrated by the Knuth-Morris-Pratt algorithm used for substring searching.<br>- Greedy Algorithms: Choosing locally optimal solutions, as illustrated by Huffman encoding.<br>- Backtracking: Exploring all possible solutions, eliminating paths that violate constraints, as seen in the N-Queens Problem.<br>These techniques provide versatile tools for addressing diverse challenges, emphasizing adaptability and efficiency in problem-solving.</p>
      <p>Reflection on Problem-Solving Approaches<br>1. Efficiency and Trade-offs: Selecting an efficient approach requires balancing constraints, considering factors like time, space, and implementation complexity. For example, Iâd prefer Quick Sort for general use but use Merge Sort for stability.<br>2. Balancing Constraints: In constrained designs, such as hashing, trade-offs between collision resolution techniques guide design decisions.<br>3. Simplicity vs. Optimization: In cases where resources are scarce, simplicity usually wins over optimization. For example, using an iterative solution for factorial when recursion may cause stack overflow.<br>4. Divide and Conquer: Breaking down a problem into smaller parts makes the design easier. Dynamic programming is a good example of this with its overlapping subproblems.<br>5. Overcoming Weaknesses: Identifying bottlenecks, such as hash collisions or unbalanced trees, leads to adaptive solutions like AVL or Red-Black Trees.<br>6. Cross-context Knowledge: Known solutions to new domains can be
