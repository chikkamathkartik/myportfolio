<!DOCTYPE html>
<html>

<head>
  <title>Modern Learning Portfolio</title>
  <style>
    /* General Styles */
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #1e293b, #0f172a);
      color: #ffffff;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    .container {
      width: 90%;
      max-width: 1200px;
      margin: 20px auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* Header Styles */
    header {
      text-align: center;
      background: linear-gradient(135deg, #4f46e5, #9333ea);
      color: white;
      padding: 20px 10px;
      border-radius: 15px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      animation: fadeIn 1.5s ease-out;
    }

    header h1 {
      margin: 0;
      font-size: 2.5rem;
    }

    /* Navigation Menu */
    nav {
      margin: 20px 0;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 25px;
    }

    nav a {
      text-decoration: none;
      background: linear-gradient(135deg, #2563eb, #7c3aed);
      color: white;
      padding: 15px 30px;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: bold;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease-in-out;
      position: relative;
    }

    nav a:hover {
      background: linear-gradient(135deg, #9333ea, #4f46e5);
      transform: scale(1.1) rotate(3deg);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    /* Page Sections */
    .page {
      display: none;
      width: 100%;
      background: linear-gradient(135deg, #1e293b, #334155);
      padding: 25px;
      border-radius: 15px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      margin-bottom: 20px;
      color: #f3f4f6;
      animation: slideIn 0.5s ease-out;
    }

    .show-page {
      display: block;
    }

    .page h2 {
      margin-top: 0;
      text-align: center;
      color: #60a5fa;
      border-bottom: 2px solid #7c3aed;
      padding-bottom: 10px;
    }

    .page p {
      line-height: 1.8;
      margin: 10px 0;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-left: 4px solid #2563eb;
    }

    /* Footer */
    footer {
      text-align: center;
      background: linear-gradient(135deg, #9333ea, #4f46e5);
      color: white;
      padding: 15px;
      width: 100%;
      margin-top: auto;
      border-radius: 0 0 15px 15px;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-50px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Button Wiggle Animation */
    @keyframes wiggle {

      0%,
      100% {
        transform: rotate(0deg);
      }

      25% {
        transform: rotate(-3deg);
      }

      50% {
        transform: rotate(3deg);
      }

      75% {
        transform: rotate(-3deg);
      }
    }

    nav a:active {
      animation: wiggle 0.3s ease-in-out;
    }
  </style>
</head>

<body>

  <div class="container">
    <!-- Header -->
    <header>
      <h1>Learning Portfolio</h1>
    </header>

    <!-- Navigation -->
    <nav>
      <a href="#home">Home</a>
      <a href="#project">Project Intro</a>
      <a href="#learning">Reflections</a>
    </nav>

    <!-- Sections -->
    <section id="home" class="page show-page">
      <h2>Home Page</h2>
      <p>Welcome to the Learning Portfolio! Explore the projects, reflections, and insights shared here.</p>
    </section>

    <section id="project" class="page">
      <h2>Project Introduction</h2>
      <p>This section introduces the project objectives, methods, and outcomes.</p>
    </section>

    <section id="learning" class="page">
      <h2>Learning Reflections</h2>
      <p>Gain insights from the learning journey, including challenges and key takeaways.</p>
      <p>In computational problem solving, we encounter different types of problems that mimic the patterns we observe in nature. At a broad level, these can be categorized as iterative, recursive, and backtracking problems. Iterative problems involve repeating a set of operations until a certain condition is met. For example, calculating factorial iteratively is a very direct application. The second meaningful method is recursion, in which a function resolves a problem by calling itself in smaller steps, the Tower of Hanoi or the Fibonacci sequence. Other methods include backtracking, which proves useful for constraint-based problems, such as the N-Queens Problem, in which solutions are constructed incrementally but abandoned when such paths fail to meet given constraints. In particular, algorithms reflect the natural pattern of solving a problem when it involves conditions of complexity and also constraints.</p>
      <p>Space and time efficiency measure how well an algorithm uses computational resources. Time complexity measures the number of operations required as the input size grows, while space complexity measures memory usage. The importance of these efficiencies is that they directly impact the performance of algorithms in real-world applications. Orders of growth explain the relationship between input size and resource requirements: constant (O(1)), logarithmic (O(log n)), linear (O(n)), quadratic (O(n²)), and exponential (O(2^n)). Some sorting algorithms, for example Quick Sort, are O(n log n), an efficient balance between using resources and producing performance. Understanding these concepts allows one to choose the best algorithms for different problems.</p>
      <p>Chapter 2 Hashing and Hash Tables: A number of design principles are mentioned here:
      <ul>
        <li>Hash Functions: Good hash functions avoid collisions and distribute data evenly so that operations like insertion and search take constant time, O(1).</li>
        <li>Collision Avoidance Techniques: Chaining and open addressing are techniques used to handle collisions. Chaining stores collided elements in linked lists, while open addressing searches for an alternative slot.</li>
        <li>Practical Applications: Hash tables show that good theoretical work actually translates to very real-world efficiency. They underlie data retrieval systems such as dictionaries and caches. These illustrate why good design should balance efficiency and flexibility.</li>
      </ul>
      </p>
      <p>Trees represent hierarchical data and solve numerous problems in computer science. In BST, all three operations searching, insertion and deletion can be done efficiently - that is, O(log n) - if they remain balanced. AVL Trees enhance BSTs by maintaining balance through rotations, ensuring logarithmic performance. Red-Black Trees extend balancing with color-based rules, widely used in databases and file systems. Heaps prioritize quick access to the largest or smallest elements, as seen in priority queues. Tries excel in prefix-based searches, crucial in autocomplete and spellcheck features. Each tree structure optimizes specific problem scenarios, demonstrating the adaptability of hierarchical data representations.</p>
      <p>Array query algorithms address issues like accessing, modification, and data analysis. For example, with prefix sums or segment trees, range queries are computed in very little time. In searching operations, arrays make use of the binary search optimization, where their complexity is of logarithmic time, O(log n), hence making arrays core in handling structured data. The applications include such diverse fields as database indexing, computational biology, thus underlining versatility and necessity in robust query mechanisms.</p>
      <p>Trees and graphs are both relation representations but fundamentally different. Trees are hierarchical structures with a single root and acyclic connections. Graphs generalize this concept, allowing cycles and multiple root-like nodes. Tree traversal methods, such as Inorder, Preorder, and Postorder, are linear and well-defined. Graph traversal, encompassing Depth-First Search (DFS) and Breadth-First Search (BFS), adapts to cyclic and acyclic scenarios. Trees are great for hierarchical representations like file systems, and graphs solve complex network problems like social connections or transportation systems. The diversity of their application underlines the adaptability of data structures to various applications.</p>
      <p>Sorting and searching are foundational algorithmic techniques. Sorting methods, such as Quick Sort (divide and conquer) and Merge Sort (stable and efficient), order data efficiently for further processing. Searching algorithms, including binary search, find elements in sorted datasets with logarithmic complexity. Real-world applications abound: search engines rely on efficient algorithms to retrieve information, while sorting underpins database query optimizations. These techniques bridge theoretical design with practical utility.</p>
      <p>Graph algorithms solve key problems such as finding spanning trees and shortest paths. Minimum Spanning Tree algorithms, like Kruskal's and Prim's, optimize network connections such as power grids or communication networks. Shortest path algorithms, like Dijkstra's or A*, give the best route in navigation systems. These applications show how graph algorithms can translate hard problems into implementable solutions and how important it is in today's computation.</p>
      <p>The course discusses the following methodologies for algorithm design:
      <ul>
        <li>Divide and Conquer: Breaking down problems into smaller subproblems, as seen in Merge Sort.</li>
        <li>Dynamic Programming: Solving overlapping subproblems, as illustrated by the Knuth-Morris-Pratt algorithm used for substring searching.</li>
        <li>Greedy Algorithms: Choosing locally optimal solutions, as illustrated by Huffman encoding.</li>
        <li>Backtracking: Exploring all possible solutions, eliminating paths that violate constraints, as seen in the N-Queens Problem.</li>
      </ul>
      These techniques provide versatile tools for addressing diverse challenges, emphasizing adaptability and efficiency in problem-solving.</p>
      <p>**Reflection on Problem-Solving Approaches**
      <ul>
        <li>Efficiency and Trade-offs: Selecting an efficient approach requires balancing constraints, considering factors like time, space, and implementation complexity. For example, I’d prefer Quick Sort for general use but use Merge Sort for stability.</li>
        <li>Balancing Constraints: In constrained designs, such as hashing, trade-offs between collision resolution techniques guide design decisions.</li>
        <li>Simplicity vs. Optimization: In cases where resources are scarce, simplicity usually wins over optimization. For example, using an iterative solution for factorial when recursion may cause stack overflow.</li>
        <li>Divide and Conquer: Breaking down a problem into smaller parts makes the design easier. Dynamic programming is a good example of this with its overlapping subproblems.</li>
        <li>Overcoming Weaknesses: Identifying bottlenecks, such as hash collisions or unbalanced trees, leads to adaptive solutions like AVL or Red-Black Trees.</li>
        <li>Cross-context Knowledge: Known solutions to new domains can be applied to demonstrate the strength of adaptive techniques, such as graph algorithms in bioinformatics or social network analysis.</li>
        <li>Patterns in Complexity: Patterns in datasets simplify the application of algorithms and aid decisions like hashing vs. search trees.</li>
        <li>Innovation vs. Tradition: Situations that require fast deployment might rely on proven solutions, while unique challenges can lead to innovation.</li>
        <li>Efficacy of Solutions: Evaluation of solutions also takes into account parameters such as speed of execution, memory usage, and adaptability. For example, the efficiency of a solution is increased if it is capable of adapting in response to unanticipated increases in data volume.</li>
        <li>Adaptability of Solutions: Tackling unforeseen problems often requires modification or improvement of existing algorithms. For example, changing a graph traversal algorithm to include weighted edges ensures robustness in changing scenarios.</li>
        <li>Pattern Recognition: Techniques such as looking at data structures for their inherent properties or recognizing patterns of recurring subproblems help in choosing efficient algorithms.</li>
        <li>Design Innovation: Whether one should innovate would depend on the cost of development versus potential benefits. Solutions that have been tried and tested are often good enough for traditional problems, but innovative designs are necessary in novel or very high-impact problems.</li>
      </ul>
      These principles capture the nature of iterative and incremental problem-solving, thus encouraging effective and innovative solutions.</p>
    </section>
  </div>

  <!-- Footer -->
  <footer>
    © 2024 Kartik Chikkamath. All rights reserved.
  </footer>

  <script>
    // Navigation behavior
    const pages = document.querySelectorAll('.page');
    document.querySelectorAll('nav a').forEach(link => {
      link.addEventListener('click', (event) => {
        event.preventDefault();
        pages.forEach(page => page.classList.remove('show-page'));
        const targetPage = document.querySelector(link.getAttribute('href'));
        targetPage.classList.add('show-page');
      });
    });
  </script>
</body>

</html>
